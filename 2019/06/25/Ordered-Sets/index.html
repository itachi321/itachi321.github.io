<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Ordered Sets | Itachi's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Ordered Sets</h1><a id="logo" href="/.">Itachi's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Ordered Sets</h1><div class="post-meta">Jun 25, 2019</div><div class="post-content"><p>[TOC]</p>
<h1 id="An-ordered-set-is-…"><a href="#An-ordered-set-is-…" class="headerlink" title="An ordered set is …"></a>An ordered set is …</h1><p>Let P be a set and ⊑ be a (partial) order on P. Then P and ⊑ form a <strong>(partially) ordered set</strong>.</p>
<p>If the order is total, so that no two elements of P are incomparable, then the ordered set is a <strong>totally ordered set</strong>. Totally ordered sets are the ones people are first familiar with. See Figure 1 for an example.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-lattice456.png" alt="Figure 1: The integers, totally ordered by ≤; a chain"></p>
<p>A totally ordered set is also termed a <strong>chain</strong>.</p>
<p>If the order is partial, so that P has two or more incomparable elements, then the ordered set is a <strong>partially ordered set</strong>. See Figure 2 for an example.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-latticePowersetAbc.png" alt="Figure 2: The powerset of {a, b, c}, ordered by ⊆"></p>
<p>At the other extreme, if no two elements are comparable unless they are equal, then the ordered set is an <strong>antichain</strong>. See Figure 3.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-antichain.png" alt="Figure 3: Incomparable items forming an antichain"></p>
<p>On any set, = is an order; this is termed the <strong>discrete order</strong> on the set. Any set ordered by = forms an antichain.</p>
<p>It is common for people to refer briefly though inaccurately to an ordered set as an <strong>order</strong>, to a totally ordered set as a <strong>total order</strong>, and to a partially ordered set as a <strong>partial order</strong>. It is usually clear by context whether “order” refers literally to an order (an order relation) or by synecdoche to an ordered set.</p>
<p>Examples:</p>
<ol>
<li>The integers with ≤ form an ordered set (see Figure 1). ≤ is a total order on the integers, so this ordered set is a chain.</li>
<li>Any powerset with ⊆ forms an ordered set (see Figure 2). This is a partially ordered set because not all subsets are related by ⊆, for example {a} || {b, r}.</li>
<li>A set of unrelated items, ordered by =, is the discrete order on that set and forms an antichain (see Figure 3).</li>
<li>The classes in java.util with the subclass relation form an ordered set (see Figure 4). This set is partially ordered, because not all classes in the set are related by the subclass relations (for example, Vector and HashSet are not related and are thus incomparable: Vector || HashSet).<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-po.java.util.png" alt="Figure 4: Part of the java.util inheritance structure"></li>
<li>A set of binary strings with the prefix relation forms an ordered set (see Figure 5). This is set is partially ordered because not all strings are related by the prefix relation, for example 01 || 10.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-po.binaryStrings3.png" alt="Figure 5: The binary strings no longer than 3, ordered by the prefix relation ≤"></li>
<li>The (non-empty) conjunctions of any of the propositions p, q, and r, ordered by implication, form an ordered set (see Figure 6). In this set, p∧q implies q, but p∧q neither implies nor is implied by q∧r, so p∧q and q∧r are incomparable (p∧q # q∧r) .<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-latticeConjunctionPqr.png" alt="Figure 6: The conjunctions of any of p, q, and r, ordered by implication"></li>
<li>The positive integers N with the divisibility relation form an ordered set. The divisibility relation relates m to n if m divides n, written m | n. Thus 2 | 6, and 3 | 6 but not 4 | 6 (i.e., 4 and 6 are incomparable, written 4 || 6) because 4 does not divide 6. And for any n∈N, 1 | n and n | n. A part of this ordered set is shown in Figure 7.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-po.divisibility15.png" alt="Figure 7: The positive integers to 15, ordered by the divisibility relation"></li>
</ol>
<h1 id="Duality"><a href="#Duality" class="headerlink" title="Duality"></a>Duality</h1><p>Duality<br>Each ordered set P corresponds to another ordered set $P^∂$, the <strong>dual</strong> of P, defined by: y⊑x in $P^∂$ iff x⊑y in P.</p>
<p>Each statement Φ about P corresponds to a <strong>dual statement</strong> $Φ^∂$ about $P^∂$. $Φ^∂$ is obtained by replacing each occurrence of ⊑ in Φ by ⊒, and each occurrence of ⊒ in Φ by ⊑. Φ is true about P if and only if $Φ^∂$ is true about $P^∂$. Generalizing, it can be shown that if a statement Φ is true about all ordered sets, then its dual statement $Φ^∂$ is also true. This assertion is the <strong>Duality Principle</strong>.</p>
<p>Pairs of dual concepts that are defined in terms of ⊑ and ⊒ (such as upper bound and lower bound, below), are also exchanged in dual statements.</p>
<p>Example: Let Q be the ordered set shown in Figure 7, in which ⊑ is the integer divides relation, with the divisor “lower than” the dividend. Then the ordered set of the positive integers to 15 ordered by the converse of divides (now with the divisor considered “higher” than the dividend), is the dual $Q^∂$ of Q. The converse of |, $|^{-1}$, relates two integers if one divides the other, but unlike | it classifies the numerically-smaller integer as the “higher” one by this relation, so that for this order 2⊑1, for example. $Q^∂$ is shown in Figure 8. In Q, 4⊑8, so we know without looking at Figure 8 that in $Q^∂$, the dual statement 4⊒8 holds in the relation for that ordered set.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-po.divisibility15dual.png" alt="Figure 8: The dual of the ordered set in Figure 7"></p>
<h1 id="Extrema"><a href="#Extrema" class="headerlink" title="Extrema"></a>Extrema</h1><p>Let S be an ordered set.</p>
<ul>
<li>u∈S is said to be <strong>maximal</strong> in S iff there is no v∈S such that u≤v. A set may have any number of maximal elements, including zero.</li>
<li>If u is S’s only maximal element, then u is the <strong>maximum</strong> of S.</li>
<li>The maximum element u (if it exists) is also called the <strong>top</strong> of S and is denoted by ⊤.</li>
<li>Dually, t∈S is said to be <strong>minimal</strong> in S iff there is no s∈S such that s≤t. A set may have any number of minimal elements, including zero.</li>
<li>If t is S’s only minimal element, then t is the <strong>minimum</strong> of S.</li>
<li>The minimum element t (if it exists) is also called the <strong>bottom</strong> of S and is denoted by ⊥.</li>
</ul>
<p>Examples:</p>
<ol>
<li>p∧q∧r is a maximal element of the set in Figure 6. Since it is the only maximal element, it is the maximum or top.</li>
<li>The set in Figure 6 has three minimal elements (p, q, and r). It has no minimum (because it has three minimal elements).</li>
<li>The set of all integers has no maximal or minimal elements (Figure 1). It has no maximum (because it has no maximal elements); similarly, it has no minimum.</li>
</ol>
<h1 id="Bounds"><a href="#Bounds" class="headerlink" title="Bounds"></a>Bounds</h1><h2 id="Upper-bounds-and-LUBs"><a href="#Upper-bounds-and-LUBs" class="headerlink" title="Upper bounds and LUBs"></a>Upper bounds and LUBs</h2><p>Let S be an ordered set and let E⊆S.</p>
<ul>
<li>y∈S is an <strong>upper bound</strong> of E iff x≤y for every x∈E. E may have no upper bound, one upper bound, or many. Note that y need not be an element of E in order to be an upper bound of E.</li>
<li>We write EU to denote the set of all upper bounds of E. EU may be empty, a singleton, or have many members.</li>
<li>If Eu is non-empty and has a minimum element u, then u is called the <strong>least upper bound (LUB)</strong> of E, written ∨E. The LUB of E is also called the <strong>supremum</strong> or <strong>join</strong> of E.<br>In the common case where E consists of exactly two elements s and t, we can also write s∨t (pronounced “the least upper bound of s and t” or “s join t”).</li>
</ul>
<p>Examples, using the ordered set of Figure 5 as S:<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-po.binaryStrings3.png" alt="Figure 5 (again): The binary strings no longer than 3, ordered by the prefix relation (with prefix low)"></p>
<ol>
<li>Consider E={01}. E has several upper bounds in S, 01 itself, 010, and 011, so $E^U$={01,010,011}. $E^U$ has a minimum element under the prefix relation ≤, and that minimum is 01, so E={01} has a LUB of 01 in S.</li>
<li>Consider E={00,01}. There is no element of S that is greater than both 00 and 01. E thus has no upper bound in S, and $E^U$ is empty. $E^U$ has no minimum element under the prefix relation ≤ (because it has no elements at all), so E has no LUB in S.</li>
</ol>
<h2 id="Lower-bounds-and-GLBs"><a href="#Lower-bounds-and-GLBs" class="headerlink" title="Lower bounds and GLBs"></a>Lower bounds and GLBs</h2><p>The dual concept for upper bound is lower bound, and analogous definitions apply.</p>
<ul>
<li>z∈S is a <strong>lower bound</strong> of E iff z≤x for every x∈E. Note that z need not be an element of E in order to be a lower bound of E.</li>
<li>We write EL to denote the set of all lower bounds of E.</li>
<li>If EL is non-empty and has a maximum element v, then v is called the <strong>greatest lower bound (GLB)</strong> of E, written ∧E. The GLB of E is also called the <strong>infimum</strong> or <strong>meet</strong> of E.<br>In the common case where E consists of exactly two elements s and t, we can also write s∧t (pronounced “the greatest lower bound of s and t” or “s meet t”).</li>
</ul>
<p>Examples:</p>
<ol>
<li>(Figure 5)  000 ∨ 001 is 00.</li>
<li>(Figure 3)  { scrambled eggs, Jane Eyre } has no GLB because it has no lower bound at all.</li>
</ol>
<h2 id="Existence-of-LUBs-and-GLBs"><a href="#Existence-of-LUBs-and-GLBs" class="headerlink" title="Existence of LUBs and GLBs"></a>Existence of LUBs and GLBs</h2><p>A LUB (GLB) can fail to exist for either of two reasons:</p>
<ol>
<li>There may be no upper (lower) bound at all; $E^U$ ($E^L$) may be empty (for example, the binary strings in Figure 5 and {000, 001}).</li>
<li>There may be upper (lower) bounds, but no least upper bound (greatest lower bound).<br> a. There may be two or more minimal upper bounds (maximal lower bounds) that are not comparable, so that neither can be least (greatest) (for example, the divisibility ordering in Figure 7 and {2, 3}); or<br> b. There may be an infinite descending (ascending) chain of upper (lower) bounds, so that none is minimal (maximal) (for example, as in the case of the reals with &lt;).</li>
</ol>
<h2 id="LUB-and-GLB-synonyms-and-symbols"><a href="#LUB-and-GLB-synonyms-and-symbols" class="headerlink" title="LUB and GLB synonyms and symbols"></a>LUB and GLB synonyms and symbols</h2><p>The table below gives the several synonyms and symbols related to greatest lower bound and least upper bound.<br>| Name                 | Abbrev. | Synonyms       | Operator | Goes with … |<br>| —————————— | ———- | ——————— | ———— | —————- |<br>| least upper bound    | LUB     | supremum, join | ∨        | top ⊤       |<br>| greatest lower bound | GLB     | infimum, meet  | ∧        | bottom ⊥    |</p>
<h1 id="Lifting"><a href="#Lifting" class="headerlink" title="Lifting"></a>Lifting</h1><p>It is often useful for an ordered set to have a bottom, but not all ordered sets have one (for example, the set in Figure 6). In this case, we can produce a new ordered set with a bottom by adding a (new) least element to the original ordered set. This process is called <strong>lifting</strong>, and the result of lifting an ordered set P can be called “P lifted”, written $P_⊥$.</p>
<p>Example: The non-empty conjunctions of any of p, q, and r, ordered by implication (see Figure 6), has no bottom element. We can lift this set by adding a new element, ⊥, which is implied by all other elements. Here, ⊥ may be thought of as representing the conjunction of 0 propositions. The lifted set is diagrammed in Figure 9. In terms of the knowledge expressed by each conjunction, we may say that a conjunction is an assertion that we know each of its conjuncts is true; thus, for example, p∧r is an assertion that we know p is true and we know r is true. Then ⊥ is an empty assertion, one that does not assert that we know that any of p, q, or r are true.<br><img src="https://thomasalspaugh.org/pub/fnd/img/orderedSet-latticeConjunctionPqrLifted.png" alt="Figure 9: The ordered set of Figure 6, lifted"></p>
<h1 id="Diagrams"><a href="#Diagrams" class="headerlink" title="Diagrams"></a>Diagrams</h1><p>We have been using diagrams of ordered sets without defining what they mean, relying on the reader’s intuition. It is time to confirm that intuition by defining what the diagrams mean.</p>
<p>First we must consider the concept of covering. For x,y ∈ set P ordered by ≤, we say x <strong>is covered by</strong> y (written x⤙y) if x&lt;y and for any z∈P, x≤z&lt;y implies x=z. This means that there is no element of P “between” x and y. Equivalently, we say y covers x.</p>
<p>A diagram (or Hasse diagram) of an ordered set is a graph in which</p>
<p>each node corresponds to an element of the set,<br>each edge corresponds to a covering relation between the nodes it connects, and<br>if x⤙y, then the node for x is drawn in a lower position than the node for y.<br>Thus we see that in interpreting diagrams, it does not matter whether one node is above or below another unless there is a monotonic path between them; and that if there is a monotonic path from y through one or more nodes down to x, there is no separate edge directly from y to x.</p>
<p>Examples in Figure 9:</p>
<p>p∧q covers p (because no other node is between them). We may also write p is covered by p∧q or p⤙p∧q.<br>The figure indicates that p∧q∧r implies q. Even though there is no line directly from p∧q∧r to q, we know this because there is a monotonically-descending path from p∧q∧r to q.<br>There are non-monotonic paths from p∧q to q∧r (for example, down to q and back up), but this doesn’t mean that p∧q implies q∧r, because none of the paths are monotonically descending. In fact, p∧q || q∧r.<br>Other examples:</p>
<p>In Figure 7, 5 is below 9 but this doesn’t mean that 5 | 9 because there is no monotonic path between them. In fact, 5 || 9.</p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.jpg&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/06/17/tamarin-builtin/">tamarin Built-in message theories</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/函数式编程/">函数式编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全协议/">安全协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/形式化/">形式化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Haskell/" style="font-size: 15px;">Haskell</a> <a href="/tags/tamarin/" style="font-size: 15px;">tamarin</a> <a href="/tags/形式化/" style="font-size: 15px;">形式化</a> <a href="/tags/TLS/" style="font-size: 15px;">TLS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/25/Ordered-Sets/">Ordered Sets</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/tamarin-builtin/">tamarin Built-in message theories</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/Haskell介绍/">Haskell介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/30/TLS1-3/">TLS1.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://csp.whu.edu.cn" title="珞珈之戍" target="_blank">珞珈之戍</a><ul></ul><a href="https://zhangtong16.github.io/" title="zhangtong16" target="_blank">zhangtong16</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Itachi's Blog.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>