<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>【第一章】我的最爱Lambda演算 | Itachi's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【第一章】我的最爱Lambda演算</h1><a id="logo" href="/.">Itachi's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【第一章】我的最爱Lambda演算</h1><div class="post-meta">Feb 9, 2020</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda演算的语法"><span class="toc-number">1.</span> <span class="toc-text">Lambda演算的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#柯里化"><span class="toc-number">1.1.</span> <span class="toc-text">柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自由标识符-vs-绑定标识符"><span class="toc-number">1.2.</span> <span class="toc-text">自由标识符 vs. 绑定标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda演算运算法则"><span class="toc-number">2.</span> <span class="toc-text">Lambda演算运算法则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Alpha转换"><span class="toc-number">2.1.</span> <span class="toc-text">Alpha转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beta规约"><span class="toc-number">2.2.</span> <span class="toc-text">Beta规约</span></a></li></ol></li></ol></div></div><div class="post-content"><p>lambda演算系列搬运cgnail的blog，源blog连接为<a href="http://cgnail.github.io/academic/lambda-index/" target="_blank" rel="noopener">这里</a>。</p>
<p>计算机科学，尤其是编程语言，经常倾向于使用一种特定的演算：Lambda演算（Lambda Calculus）。这种演算也广泛地被逻辑学家用于学习计算和离散数学的结构的本质。Lambda演算伟大的的原因有很多，其中包括：</p>
<ul>
<li>非常简单。</li>
<li>图灵完备。</li>
<li>容易读写。</li>
<li>语义足够强大，可以从它开始做（任意）推理。</li>
<li>它有一个很好的实体模型。</li>
<li>容易创建变种，以便我们探索各种构建计算或语义方式的属性。</li>
</ul>
<p>Lambda演算易于读写，这一点很重要。它导致人们开发了很多极为优秀的编程语言，他们在不同程度上都基于Lambda演算：LISP，ML和Haskell语言都极度依赖于Lambda演算。</p>
<p>Lambda演算建立在函数的概念的基础上。纯粹的Lambda演算中，一切都是函数，连值的概念都没有。但是，我们可以用函数构建任何我们需要的东西。还记得在这个博客的初期，我谈了一些关于如何建立数学的方法么？ 我们可以从无到有地用Lambda演算建立数学的整个结构。</p>
<p>闲话少说，让我们深入的看一看LC（Lambda Calculus）。对于一个演算，需要定义两个东西：语法，它描述了如何在演算中写出合法的表达式；一组规则，让你符号化地操纵表达式。</p>
<h2 id="Lambda演算的语法"><a href="#Lambda演算的语法" class="headerlink" title="Lambda演算的语法"></a>Lambda演算的语法</h2><p>Lambda演算只有三类表达式：</p>
<ol>
<li>函数定义：Lambda演算中的函数是一个表达式，写成：<code>lambda x . body</code>，表示“一个参数参数为<code>x</code>的函数，它的返回值为<code>body</code>的计算结果。” 这时我们说：Lambda表达式绑定了参数<code>x</code>。</li>
<li>标识符引用（Identifier reference）：标识符引用就是一个名字，这个名字用于匹配函数表达式中的某个参数名。</li>
<li>函数应用（Function application）：函数应用写成把函数值放到它的参数前面的形式，如<code>(lambda x . plus x x) y</code>。</li>
</ol>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>在Lambda演算中有一个技巧：如果你看一下上面的定义，你会发现一个函数（Lambda表达式）只接受一个参数。这似乎是一个很大的局限 —— 你怎么能在只有一个参数的情况下实现加法？</p>
<p>这一点问题都没有，因为函数就是值。你可以写只有一个参数的函数，而这个函数返回一个带一个参数的函数，这样就可以实现写两个参数的函数了——本质上两者是一样的。这就是所谓的柯里化（Currying），以伟大的逻辑学家Haskell Curry命名。</p>
<p>例如我们想写一个函数来实现<code>x + y</code>。我们比较习惯写成类似：<code>lambda x y . plus x y</code>之类的东西。而采用单个参数函数的写法是：我们写一个只有一个参数的函数，让它返回另一个只有一个参数的函数。于是<code>x + y</code>就变成一个单参数<code>x</code>的函数，它返回另一个函数，这个函数将<code>x</code>加到它自己的参数上：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda <span class="keyword">x</span>. ( lambda y. plus <span class="keyword">x</span> y )</span><br></pre></td></tr></table></figure>
<p>现在我们知道，添加多个参数的函数并没有真正添加任何东西，只不过简化了语法，所以下面继续介绍的时候，我会在方便的时候用到多参数函数。</p>
<h3 id="自由标识符-vs-绑定标识符"><a href="#自由标识符-vs-绑定标识符" class="headerlink" title="自由标识符 vs. 绑定标识符"></a>自由标识符 vs. 绑定标识符</h3><p>有一个重要的语法问题我还没有提到：闭包（closure）或者叫完全绑定（complete binding）。在对一个Lambda演算表达式进行求值的时候，不能引用任何未绑定的标识符。如果一个标识符是一个闭合Lambda表达式的参数，我们则称这个标识符是（被）绑定的；如果一个标识符在任何封闭上下文中都没有绑定，那么它被称为自由变量。</p>
<ul>
<li><code>lambda x . plus x y</code>：在这个表达式中，<code>y</code>和<code>plus</code>是自由的，因为他们不是任何闭合的Lambda表达式的参数；而<code>x</code>是绑定的，因为它是函数定义的闭合表达式<code>plus x y</code>的参数。</li>
<li><code>lambda x y . y x</code> ：在这个表达式中<code>x</code>和<code>y</code>都是被绑定的，因为它们都是函数定义中的参数。</li>
<li><code>lambda y . (lambda x . plus x y)</code>：在内层演算<code>lambda x . plus x y</code>中，<code>y</code>和<code>plus</code>是自由的，<code>x</code>是绑定的。在完整表达中，<code>x</code>和<code>y</code>是绑定的：<code>x</code>受内层绑定，而<code>y</code>由剩下的演算绑定。<code>plus</code>仍然是自由的。</li>
</ul>
<p>我们会经常使用<code>free(x)</code>来表示在表达式<code>x</code>中自由的标识符。</p>
<p>一个Lambda演算表达式只有在其所有变量都是绑定的时候才完全合法。但是，当我们脱开上下文，关注于一个复杂表达式的子表达式时，自由变量是允许存在的——这时候搞清楚子表达式中的哪些变量是自由的就显得非常重要了。</p>
<h2 id="Lambda演算运算法则"><a href="#Lambda演算运算法则" class="headerlink" title="Lambda演算运算法则"></a>Lambda演算运算法则</h2><p>Lambda演算只有两条真正的法则：称为Alpha和Beta。Alpha也被称为「转换」，Beta也被称为「规约」。</p>
<h3 id="Alpha转换"><a href="#Alpha转换" class="headerlink" title="Alpha转换"></a>Alpha转换</h3><p>Alpha是一个重命名操作; 基本上就是说，变量的名称是不重要的：给定Lambda演算中的任意表达式，我们可以修改函数参数的名称，只要我们同时修改函数体内所有对它的自由引用。</p>
<p>所以 —— 例如，如果有这样一个表达式：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lambda</span> x . <span class="keyword">if</span> (= x <span class="number">0</span>) <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们可以用Alpha转换，将<code>x</code>变成<code>y</code>（写作<code>alpha[x / y]</code>），于是我们有：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lambda</span> y . <span class="keyword">if</span> (= y <span class="number">0</span>) <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> y ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这样丝毫不会改变表达式的含义。但是，正如我们将在后面看到的，这一点很重要，因为它使得我们可以实现比如递归之类的事情。</p>
<h3 id="Beta规约"><a href="#Beta规约" class="headerlink" title="Beta规约"></a>Beta规约</h3><p>Beta规约才是精彩的地方：这条规则使得Lambda演算能够执行任何可以由机器来完成的计算。</p>
<p>Beta基本上是说，如果你有一个函数应用，你可以对这个函数体中和对应函数标识符相关的部分做替换，替换方法是把标识符用参数值替换。这听起来很费解，但是它用起来却很容易。</p>
<p>假设我们有一个函数应用表达式：“ <code>(lambda x . x + 1) 3</code> “。所谓Beta规约就是，我们可以通过替换函数体（即“<code>x + 1</code>”）来实现函数应用，用数值“<code>3</code>”取代引用的参数“<code>x</code>”。于是Beta规约的结果就是“<code>3 + 1</code>”。</p>
<p>一个稍微复杂的例子：<code>(lambda y . (lambda x . x + y)) q</code>。 这是一个挺有意思的表达式，因为应用这个Lambda表达式的结果是另一个Lambda表达式：也就是说，它是一个创建函数的函数。这时候的Beta规约，需要用标识符“<code>q</code>”替换所有的引用参数“<code>y</code>”。所以，其结果是“ <code>lambda x . x + q</code>“。</p>
<p>再给一个让你更不爽的例子：“ <code>(lambda x y. x y) (lambda z . z * z) 3</code> “。这是一个有两个参数的函数，它(的功能是)把第一个参数应用到第二个参数上。当我们运算时，我们替换第一个函数体中的参数“<code>x</code>”为“<code>lambda z . z * z</code> “；然后我们用“<code>3</code>”替换参数“<code>y</code>”，得到：“ <code>(lambda z . z * z) 3</code> “。 再执行Beta规约，有“<code>3 * 3</code>”。</p>
<p>Beta规则的形式化写法为：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lambda</span> x . <span class="keyword">B </span>e = <span class="keyword">B[x </span>:= e] <span class="meta">if</span> free(e) <span class="keyword">subset </span>free(<span class="keyword">B[x </span>:= e])</span><br></pre></td></tr></table></figure>
<p>最后的条件“<code>if free(e) subset free(B[x := e])</code>”说明了为什么我们需要Alpha转换：我们只有在不引起绑定标识符和自由标识符之间的任何冲突的情况下，才可以做Beta规约：如果标识符“<code>z</code>”在“<code>e</code>”中是自由的，那么我们就需要确保，Beta规约不会导致“<code>z</code>”变成绑定的。如果在“<code>B</code>”中绑定的变量和“<code>e</code>”中的自由变量产生命名冲突，我们就需要用Alpha转换来更改标识符名称，使之不同。</p>
<p>例子更能明确这一点：假设我们有一个函数表达式，“ <code>lambda z . (lambda x . x + z)</code>“，现在，假设我们要应用它：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">z</span> <span class="name">.</span> (lambda x . x + z)) (<span class="name">x</span> + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>参数“<code>(x + 2)</code>”中，<code>x</code>是自由的。现在，假设我们不遵守规则直接做Beta规约。我们会得到：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda <span class="keyword">x</span> . <span class="keyword">x</span> + <span class="keyword">x</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>原先在“<code>x + 2</code>”中自由的的变量现在被绑定了。再假设我们应用该函数：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">x</span> <span class="name">.</span> <span class="name">x</span> <span class="name"><span class="builtin-name">+</span></span> <span class="name">x</span> <span class="name"><span class="builtin-name">+</span></span> <span class="name">2</span>) <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>通过Beta规约，我们会得到“<code>3 + 3 + 2</code>”。</p>
<p>如果我们按照应有的方式先采用Alpha转换，又该如何？</p>
<ul>
<li>由 <code>alpha[x/y]</code> 有: <code>(lambda z . (lambda y . y + z)) (x + 2)</code></li>
<li>由Beta规约： <code>(lambda y . y + x + 2) 3</code></li>
<li>再由Beta规约： <code>3 + x + 2</code> 。</li>
</ul>
<p>“<code>3 + x + 2</code>”和“<code>3 + 3 + 2</code>”是非常不同的结果！</p>
<p>规则差不多就是这些。还有另外一个规则，你可以选择性地加一条被称为Eta-规约的规则，不过我们将跳过它。 我在这里描述了一个图灵完备 —— 完整有效的计算系统。 要让它变得有用，或看它如何用来做些有实际意义的事情，我们还需要定义一堆能让我们做数学计算的基本函数，条件测试，递归等，我将在下一篇文章讨论这些。</p>
<p>我们也还没有定义Lambda-演算的模型呢。（原作者在<a href="http://goodmath.blogspot.com/2006/04/more-logic-models-and-why-they-matter.html" target="_blank" rel="noopener">这里</a>和<a href="http://goodmath.blogspot.com/2006/04/correcting-my-models-post-or-why.html" target="_blank" rel="noopener">这里</a>讨论了模型的概念。）模型实际上是非常重要的！逻辑学家们在摆弄了LC好几年之后，才为其想出一个完整的模型，这是件非常重要的事情，因为虽然LC看起来是正确的，但在早期为它定义一个模型的尝试，却是失败的。毕竟，请记住，如果没有一个有效的模型，这意味着该系统的结果是毫无意义的！</p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/lambda演算/">lambda演算</a></div><div class="post-nav"><a class="pre" href="/2020/02/09/lambda演算中的数字/">【第二章】阿隆佐.丘奇的天才之作——lambda演算中的数字</a><a class="next" href="/2019/06/17/tamarin-builtin/">tamarin Built-in message theories</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODEzMS8yNDYyOA=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://itachi321.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/函数式编程/">函数式编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全协议/">安全协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/实验配置/">实验配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/形式化/">形式化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Haskell/" style="font-size: 15px;">Haskell</a> <a href="/tags/lambda演算/" style="font-size: 15px;">lambda演算</a> <a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a> <a href="/tags/tamarin/" style="font-size: 15px;">tamarin</a> <a href="/tags/形式化/" style="font-size: 15px;">形式化</a> <a href="/tags/TLS/" style="font-size: 15px;">TLS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/Ubuntu-server命令行配置shadowsocks全局代理/">Ubuntu server命令行配置SS全局代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/终章，Lambda演算建模程序即证明！/">【第七章】终章，Lambda演算建模程序即证明！</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/Lambda演算的类型/">【第六章】Lambda演算的类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/从Lambda演算到组合子演算/">【第五章】从Lambda演算到组合子演算</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/为什么是Y？/">【第四章】为什么是Y？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/Lambda演算中的布尔值和选择/">【第三章】Lambda演算中的布尔值和选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/lambda演算中的数字/">【第二章】阿隆佐.丘奇的天才之作——lambda演算中的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/lambda演算/">【第一章】我的最爱Lambda演算</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/tamarin-builtin/">tamarin Built-in message theories</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/Haskell介绍/">Haskell介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://csp.whu.edu.cn" title="珞珈之戍" target="_blank">珞珈之戍</a><ul></ul><a href="https://zhangtong16.github.io/" title="zhangtong16" target="_blank">zhangtong16</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Itachi's Blog.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>