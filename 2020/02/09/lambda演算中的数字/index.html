<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>阿隆佐.丘奇的天才之作——lambda演算中的数字 | Itachi's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">阿隆佐.丘奇的天才之作——lambda演算中的数字</h1><a id="logo" href="/.">Itachi's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">阿隆佐.丘奇的天才之作——lambda演算中的数字</h1><div class="post-meta">Feb 9, 2020</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div></div></div><div class="post-content"><p>所以，现在，让我们用lambda演算干点有趣的事。首先，为了方便起见，我将介绍些语法糖（syntactic sugar）来命名函数，以便下面遇到某些复杂的事情的时候方便我们阅读。</p>
<p>引进「全局」函数（即在我写的这些所有的关于lambda演算的介绍里都可以直接使用，而不用在每一个表达式中都声明一次这个函数的办法），我们将使用“let”表达式：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let square = lambda <span class="keyword">x</span> . <span class="keyword">x</span> ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这条表达式声明了一个名为“square”的函数，其定义是<code>lambda x . x ^ 2</code>。如果我们有“ <code>square 4</code>”，则上面的“let”表达式的等效表达式为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">square</span> <span class="name">.</span> <span class="name">square</span> <span class="name">4</span>) (<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">x</span> <span class="name">.</span> <span class="name">x</span> <span class="name">^</span> <span class="name">2</span>)</span><br></pre></td></tr></table></figure>
<p>某些例子中，我使用了数字和算术运算。但数字并不真正存在于lambda演算中，我们有的只有函数！因此，我们需要发明某种使用函数来创建数字的方式。幸运的是，邱奇（Alonzo Church），这个发明了lambda演算的天才，找出了做到这一点的办法。他的函数化的数字的版本被称为丘奇数（Church Numerals）。</p>
<p>所有的丘奇数都是带有两个参数的函数：</p>
<ul>
<li>0是“ <code>lambda s z . z</code>“。</li>
<li>1是“ <code>lambda s z . s z</code> “。</li>
<li>2是“ <code>lambda s z . s (s z)</code></li>
<li>对于任何数“<code>n</code>”，它的丘奇数是将其第一个参数应用到第二个参数上“<code>n</code>”次的函数。</li>
</ul>
<p>一个很好的理解办法是将“<code>z</code>”作为是对于零值的命名，而“<code>s</code>”作为后继函数的名称。因此，0是一个仅返回“0”值的函数；1是将后继函数运用到0上一次的函数；2则是将后继函数应用到零的后继上的函数，以此类推。</p>
<p>现在看好了，如果我们想要做加法，<code>x + y</code>，我们需要写一个有四个参数的函数；两个需要相加的数字；以及推导数字时用到的“<code>s</code>”和“<code>z</code>”：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">add</span> = lambda s z <span class="keyword">x</span> y . <span class="keyword">x</span> s (y s z)</span><br></pre></td></tr></table></figure>
<p>让我们将其柯里化，看看是怎么回事。首先，它接受两个参数，这是我们需要做加法的两个值；第二，它需要正则化（normalize）这两个参数，以使它们都使用对0（<code>z</code>）和后继值（<code>s</code>）的绑定（即，将参数都写成<code>s</code>和<code>z</code>的组合的形式）。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">add</span> = lambda <span class="keyword">x</span> y . (lambda s z . (<span class="keyword">x</span> s (y s z)))</span><br></pre></td></tr></table></figure>
<p>看下这个式子，它说的是，为了将<code>x</code>和<code>y</code>相加，先用参数“<code>s</code>”和“<code>z</code>”创建（正则化的）丘奇数“<code>y</code>”。然后应用<code>x</code>到丘奇数<code>y</code>上，这时候使用由“<code>s</code>”和“<code>z</code>”定义的丘奇数<code>y</code>。也就是说，我们得到的结果是一个函数，这个函数把自己加到另一个数字上。（要计算<code>x + y</code>，先计算 <code>y</code> 是 <code>z</code> 的几号后继，然后计算<code>x</code> 是 <code>y</code>的几号后继。）</p>
<p>让我们再进一步看看<code>2 + 3</code>的运算过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add (<span class="name">lambda</span> s z . s (<span class="name">s</span> z)) (<span class="name">lambda</span> s z . s (<span class="name">s</span> (<span class="name">s</span> z))) news newz</span><br></pre></td></tr></table></figure>
<p>为了更容易理解，对数字2和3做alpha变换，“2”用“s2”和“z2”代替，3用“s3”和“z3”代替：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add (<span class="name">lambda</span> s2 z2 . s2 (<span class="name">s2</span> z2)) (<span class="name">lambda</span> s3 z3 . s3 (<span class="name">s3</span> (<span class="name">s3</span> z3)))</span><br></pre></td></tr></table></figure>
<p>用<code>add</code>的定义做替换：</p>
<figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> x y .(<span class="name"><span class="builtin-name">lambda</span></span> s z. (<span class="name">x</span> s y s z))) (<span class="name"><span class="builtin-name">lambda</span></span> s2 z2 . s2 (<span class="name">s2</span> z2)) (<span class="name"><span class="builtin-name">lambda</span></span> s3 z3 . s3 (<span class="name">s3</span> (<span class="name">s3</span> z3)))</span><br></pre></td></tr></table></figure>
<p>对<code>add</code>做beta规约：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lambda</span> s z . (lambda <span class="built_in">s2</span> z2 . <span class="built_in">s2</span> (<span class="built_in">s2</span> z2)) s (lambda <span class="built_in">s3</span> z3 . <span class="built_in">s3</span> (<span class="built_in">s3</span> (<span class="built_in">s3</span> z3)) s z)</span><br></pre></td></tr></table></figure>
<p>然后beta规约丘奇数”3”。这步操作其实是“正则化”3：把数字3的定义里的后继函数和零函数替换成<code>add</code>的参数列表里的后继函数和零函数：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">lambda</span> s z . (lambda <span class="built_in">s2</span> z2 . <span class="built_in">s2</span> (<span class="built_in">s2</span> z2)) s (s (s (s z)))</span><br></pre></td></tr></table></figure>
<p>现在，到了最精妙的一步了。再对丘奇数”2”做beta规约。我们知道：2是一个函数，它接受两个参数：一个后继函数和0(函数)。于是，要相加2和3，我们用后继函数应用到2的第一个参数；用3的运算结果应用到第二个参数（0函数）！</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda s z . s <span class="comment">(s (s (s (s z)</span>)))</span><br></pre></td></tr></table></figure>
<p>于是，我们的结果是：丘奇数”5”！</p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/lambda演算/">lambda演算</a></div><div class="post-nav"><a class="pre" href="/2020/02/09/Lambda演算中的布尔值和选择/">Lambda演算中的布尔值和选择</a><a class="next" href="/2020/02/09/lambda演算/">我的最爱Lambda演算</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODEzMS8yNDYyOA=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://itachi321.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/函数式编程/">函数式编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全协议/">安全协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/形式化/">形式化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Haskell/" style="font-size: 15px;">Haskell</a> <a href="/tags/lambda演算/" style="font-size: 15px;">lambda演算</a> <a href="/tags/tamarin/" style="font-size: 15px;">tamarin</a> <a href="/tags/形式化/" style="font-size: 15px;">形式化</a> <a href="/tags/TLS/" style="font-size: 15px;">TLS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/终章，Lambda演算建模程序即证明！/">终章，Lambda演算建模程序即证明！</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/Lambda演算的类型/">Lambda演算的类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/从Lambda演算到组合子演算/">从Lambda演算到组合子演算</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/为什么是Y？/">为什么是Y？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/Lambda演算中的布尔值和选择/">Lambda演算中的布尔值和选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/lambda演算中的数字/">阿隆佐.丘奇的天才之作——lambda演算中的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/lambda演算/">我的最爱Lambda演算</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/tamarin-builtin/">tamarin Built-in message theories</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/Haskell介绍/">Haskell介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/30/TLS1-3/">TLS1.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://csp.whu.edu.cn" title="珞珈之戍" target="_blank">珞珈之戍</a><ul></ul><a href="https://zhangtong16.github.io/" title="zhangtong16" target="_blank">zhangtong16</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Itachi's Blog.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>