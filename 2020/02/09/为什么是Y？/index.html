<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>【第四章】为什么是Y？ | Itachi's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【第四章】为什么是Y？</h1><a id="logo" href="/.">Itachi's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【第四章】为什么是Y？</h1><div class="post-meta">Feb 9, 2020</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一点个人解释"><span class="toc-number">1.</span> <span class="toc-text">一点个人解释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Y在定义递归函数中的作用"><span class="toc-number">1.1.</span> <span class="toc-text">Y在定义递归函数中的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Y怎么来的"><span class="toc-number">1.2.</span> <span class="toc-text">Y怎么来的</span></a></li></ol></li></ol></div></div><div class="post-content"><p>lambda演算系列搬运cgnail的blog，源blog连接为<a href="&quot;http://cgnail.github.io/academic/lambda-index/&quot;">这里</a>。</p>
<p>在前面的几个帖子里，我已经建立了如何把lambda演算变成一个有用的系统的点点滴滴。 我们已经有了数字，布尔值和选择运算符。我们唯一欠缺的是重复。</p>
<p>这个有点棘手。lambda演算使用递归实现循环（递归的解释可以看<a href="http://goodmath.blogspot.com/2006/03/clarifying-recursion.html" target="_blank" rel="noopener">这里</a>）。 但是，由于在lambda演算里函数没有名字，我们得采取一些非常手段。这就是所谓的Y组合子，又名lambda不动点运算符。</p>
<p>让我们先来看看lambda演算之外的一个简单的递归函数。阶乘函数，这是标准的例子：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="built_in">n</span>) = <span class="number">1</span> <span class="built_in">if</span> <span class="built_in">n</span> = <span class="number">0</span> </span><br><span class="line">factorial(<span class="built_in">n</span>) = <span class="built_in">n</span> * factorial(<span class="built_in">n</span>-<span class="number">1</span>) <span class="built_in">if</span> <span class="built_in">n</span> &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果我们要用lambda演算来写的话，我们需要几个工具……我们需要一个测试是否为零的函数，一个乘法函数，以及一个减1的函数。</p>
<p>为了检查是否为零，我们将使用一个命名函数<code>IsZero</code>，它有三个参数：一个数字，两个值。如果数字为0，则返回第一个值；如果它不为0，则返回第二个值。</p>
<p>对于乘法——我们在制定出递归之前写不出乘法。但我们可以假设目前有一个乘法函数 <code>Mult x y</code>。</p>
<p>最后，减1函数，我们用<code>Pred x</code>表示<code>x</code>的前驱——即<code>x - 1</code>。</p>
<p>所以——第一版的阶乘，如果我们把递归调用留做空白的话，将是：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( something (Pred <span class="built_in">n</span>)))</span><br></pre></td></tr></table></figure>
<p>现在的问题是，我们怎么填上“something”，使其递归？</p>
<p>答案是一些所谓的组合子。一个组合子是一种特殊的高阶函数，它们只引用函数应用。（一个高阶函数是一个函数，它接受函数作为参数，并且返回的结果也是函数）。Y组合子非常特殊，它有近乎神奇的功能使得递归成为可能。它的样子如下：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let Y = lambda y . (lambda <span class="keyword">x</span> . y (<span class="keyword">x</span> <span class="keyword">x</span>)) (lambda <span class="keyword">x</span> . y (<span class="keyword">x</span> <span class="keyword">x</span>))</span><br></pre></td></tr></table></figure>
<p>看了公式，你就就明白为什么叫它Y了，因为它的“形状”像一个Y。为了让这一点更清晰，有时我们把它写成树的形式。下面是Y组合子的树：</p>
<p><img src="http://cgnail.github.io/images/y.jpg" alt="y-combinator"></p>
<p>Y组合子的特别之处在于它应用自身来创造本身，也就是说 <code>(Y Y) = Y (Y Y)</code>。让我们从<code>(Y Y)</code>开始看看它如何工作：</p>
<ul>
<li><code>Y Y</code></li>
<li>展开第一个<code>Y</code>：<code>(lambda y . (lambda x . y (x x)) (lambda x . y (x x))) Y</code></li>
<li>现在，beta规约：<code>(lambda x . Y (x x)) (lambda x . Y (x x))</code></li>
<li>alpha[x/z]变换第二个lambda：<code>(lambda x . Y (x x)) (lambda z. Y (z z))</code></li>
<li>beta规约：<code>Y ((lambda z. Y (z z)) (lambda z. Y (z z)))</code></li>
<li>展开前面的Y，并<code>alpha[y/a][x/b]</code>变换：<code>(lambda a . (lambda b . a (b b)) (lambda b . a (b b))) ((lambda z . Y (z z)) ( lambda z . Y (z z)))</code></li>
<li>beta规约：<code>(lambda b . ((lambda z. Y (z z)) (lambda z. Y (z z))) (b b)) (lambda b . ((lambda * z. Y (z z)) (lambda z. Y (z z))) (b b))</code></li>
</ul>
<p>现在，仔细看该表达式。这是<code>(Y (Y Y))</code> [记得前面的<code>(Y Y) = (lambda x . Y (x x)) (lambda x . Y (x x))</code>吧]。所以， <code>Y Y = Y (Y Y)</code>，这是Y的魔力：它再造了本身。<code>(Y Y) = Y (Y Y) = Y (Y (Y Y))</code>，子子孙孙无穷匮也。</p>
<p>那么，我们如何使用这个疯狂的玩意？</p>
<p>好吧，让我们拿我们的第一次尝试做一下修改。给它取个名字，并尝试使用该名字重写：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">fact</span> = lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> (<span class="built_in">fact</span> (Pred <span class="built_in">n</span>)))</span><br></pre></td></tr></table></figure>
<p>现在的问题是，“fact”不是“fact”中定义的标识符。我们如何让“fact”引用“fact”呢？好了，我们可以做一个lambda抽象，让“fact”函数作为参数传过去；于是，如果我们能找到一种方法来写“fact”，使得我们可以把它作为一个参数传给它自己，事情就搞定了。我们称之为metafact。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let metafact = lambda <span class="built_in">fact</span> . (lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> (<span class="built_in">fact</span> (Pred <span class="built_in">n</span>))))</span><br></pre></td></tr></table></figure>
<p>现在，如果我们可以应用metafact到本身，我们就得到了我们的阶乘函数。也就是说，</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fact</span> <span class="built_in">n</span> = (metafact metafact) <span class="built_in">n</span> 。</span><br><span class="line">        &lt;= (lambda <span class="symbol">f1</span> . lambda <span class="symbol">t1</span> .  <span class="symbol">t1</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="symbol">t1</span> * <span class="symbol">f1</span> (P(<span class="symbol">t1</span>))) (lambda <span class="symbol">f2</span> . lambda <span class="symbol">t2</span> .  <span class="symbol">t2</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="symbol">t2</span> * <span class="symbol">f2</span> (P(<span class="symbol">t2</span>))) <span class="built_in">n</span>  </span><br><span class="line">        &lt;= (lambda <span class="symbol">t1</span> .  <span class="symbol">t1</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="symbol">t1</span> * (lambda <span class="symbol">f2</span> . lambda <span class="symbol">t2</span> .  <span class="symbol">t2</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="symbol">t2</span> * <span class="symbol">f2</span> (P(<span class="symbol">t2</span>))) (P(<span class="symbol">t1</span>))) <span class="built_in">n</span></span><br><span class="line">        &lt;= lambda <span class="built_in">n</span> .  <span class="built_in">n</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span> * (lambda <span class="symbol">f2</span> . lambda <span class="symbol">t2</span> .  <span class="symbol">t2</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="symbol">t2</span> * <span class="symbol">f2</span> (P(<span class="symbol">t2</span>))) (P(<span class="built_in">n</span>))</span><br><span class="line">        &lt;= lambda <span class="built_in">n</span> .  <span class="built_in">n</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span> * (lambda <span class="symbol">f2</span> .  P(<span class="built_in">n</span>) ? <span class="number">1</span> <span class="symbol">:</span> P(<span class="built_in">n</span>) * <span class="symbol">f2</span> (P(P(<span class="built_in">n</span>))) ) </span><br><span class="line">        &lt;= lambda <span class="built_in">n</span> .  <span class="built_in">n</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span> * (lambda f .  (P(<span class="built_in">n</span>) ? <span class="number">1</span> <span class="symbol">:</span> P(<span class="built_in">n</span>) * f (P(P(<span class="built_in">n</span>))) )</span><br><span class="line">        &lt;= lambda <span class="built_in">n</span> . <span class="built_in">n</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span> * (lambda f . f (P(<span class="built_in">n</span>)))</span><br><span class="line">        &lt;= lambda f . lambda <span class="built_in">n</span> . <span class="built_in">n</span> ? <span class="number">1</span> <span class="symbol">:</span> <span class="built_in">n</span> * f (P(<span class="built_in">n</span>))</span><br><span class="line">        &lt;= f (<span class="built_in">n</span>)</span><br></pre></td></tr></table></figure>
<p>这正是Y的用武之地。它让我们可以创建一个古怪的结构，每次需要递归的时候都可以复制函数过来。<code>metafact (Y metafact)</code>将得到我们想要的。展开之，这就是：</p>
<figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> fact . (<span class="name"><span class="builtin-name">lambda</span></span> n . IsZero n <span class="number">1</span> (<span class="name">Mult</span> n (<span class="name">fact</span> (<span class="name">Pred</span> n))))) (<span class="name">Y</span> (<span class="name"><span class="builtin-name">lambda</span></span> fact . (<span class="name"><span class="builtin-name">lambda</span></span> n . IsZero n <span class="number">1</span> (<span class="name">Mult</span> n (<span class="name">fact</span> (<span class="name">Pred</span> n))))))</span><br></pre></td></tr></table></figure>
<p><code>(Y metafact)</code>实际上是第一个lambda中参数fact的值；当我们对它做beta规约的时候，如果n为零，那么它只是返回1，如果它不为零，那么它调用<code>fact (Pred n)</code>。 然后再将<code>fact</code>beta规约为<code>Y metafact</code>， 这个变换疯狂地复制，得到输出<code>metafact (Y metafact) (Pred n)</code>。</p>
<p>瞧，递归（<code>metafact (Y metafact) = metafact (Y metafact) (Pred n)</code>）。极度扭曲的递归。</p>
<p>我第一次了解了Y组合子是在本科，1989左右，至今我仍然觉得它很神秘。我虽然也明白它是怎么来的，但我无法想象地球上怎么会有人把它给想出来！</p>
<p>如果你对此很长感兴趣，那么我极力推荐<a href="http://www.amazon.com/gp/product/0262560992/ref=pd_sim_books/104-7045044-8378353?n=283155" target="_blank" rel="noopener">「The Little Schemer」</a>这本书。这是本非常棒的小书 —— 写得象一本儿童读物。书里要么每一页正面是一个问题，背面就是答案，要么一页分成两栏，一栏问题一栏答案。书的风格轻松幽默，不仅教你Scheme编程，更教人怎么思考。</p>
<p>一个重要的提示：实际上有几个不同的版本的Y组合子。也有几种不同的lambda演算的计算方式：给定以下表达式：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">x</span> <span class="name">y</span> <span class="name">.</span> <span class="name">x</span> <span class="name"><span class="builtin-name">*</span></span> <span class="name">y</span>) <span class="number">3</span> ((<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">z</span> <span class="name">.</span> <span class="name">z</span> <span class="name"><span class="builtin-name">*</span></span> <span class="name">z</span>) <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以按不同的顺序来计算：我们可以首先对<code>(lambda x y . x * y)</code>做beta规约，于是有：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span>* ((lambda z . z * z) <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>或者，我们可以先beta规约<code>((lambda z . z * z) 4)</code>：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">x</span> <span class="name">y</span> <span class="name">.</span> <span class="name">x</span> <span class="name"><span class="builtin-name">*</span></span> <span class="name">y</span>) <span class="number">3</span> (<span class="name">4</span> * <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>在这种情况下，两种方式得到相同的结果；但事实并非总是如此。</p>
<p>第一种顺序就是我们所说的「惰性求值」（Lazy evaluation）：我们不计算函数的参数，直到我们需要使用它们。第二种叫「急切求值」（eager evaluation）：我们总是在把参数传递给函数之前进行计算。（在实际的编程语言中，Lisp语言，Scheme，和ML使用急切求值计算lambda演算，Haskell和Miranda则使用惰性值计算lambda演算。）我上面描述的Y组合子是惰性求值。如果我们用急切求值，那么上述Y组合子是导不出来的——事实上，它会永远地复制Y。</p>
<h1 id="一点个人解释"><a href="#一点个人解释" class="headerlink" title="一点个人解释"></a>一点个人解释</h1><h2 id="Y在定义递归函数中的作用"><a href="#Y在定义递归函数中的作用" class="headerlink" title="Y在定义递归函数中的作用"></a>Y在定义递归函数中的作用</h2><p>首先，在lambda演算中，函数名不是不可缺少的，没有函数名的函数称为「匿名函数」。lambda符号的引入就是为了去掉函数名这个冗余，使定义匿名函数成为可能。但是当需要定义的函数含有递归时，比如阶乘<code>factorial</code>，也就是函数的定义部分需要引用函数自身的时候，没有函数名意味着用lambda演算无法直接引用函数自身。怎么办呢？</p>
<p>一种办法是设计另一个函数G，它接受一个函数作为参数，返回值也是一个函数（这种参数是函数的函数称为高阶函数）。然后，我们把<code>factorial</code>当做参数传给G，如果G返回的函数也是<code>factorial</code>的话，就圆满了。也就是说，这个G需要满足两个特征：</p>
<ol>
<li>G的定义中不会出现<code>factorial</code>，但是它可以接受<code>factorial</code>作为参数。回想一下一阶函数<code>f(x) = x * x</code>，它的定义里没有出现数字「1」，但是「1」可以传给它进行计算。而在构造G时，<code>factorial</code>就相当于数字「1」。</li>
<li>方程<code>G(f)=f</code>的解是<code>factorial</code>。这样我们就不用直接定义<code>factorial</code>，求解这个关于G的方程就可以得到<code>factorial</code>的定义了。</li>
</ol>
<p>于是，我们需要干两件事：找到G，和找到求解<code>G(f)=f</code>的办法。寻找G很简单，既然我们想让<code>G(factorial)=factorial</code>，那么把<code>factorial</code>定义中关于<code>factorial</code>的引用参数化就可以了，即：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let G = lambda f . lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( f (Pred <span class="built_in">n</span>)))</span><br></pre></td></tr></table></figure>
<p>这就是上面的<code>metafact</code>函数。这种构造方法可以用于构造任意递归函数的「G」。</p>
<p>然后我们需要找到求解方程<code>G(f)=f</code>的办法。满足<code>f(x)=x</code>的x称为函数<code>f</code>的不动点，<code>f</code>是高阶函数时也不例外。Y组合子的作用就是计算函数的不动点，它对所有的函数<code>f</code>都满足<code>f(Y(f)) = Y(f)</code>，推理如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Y (<span class="name">f</span>) = (<span class="name">lambda</span> y . (<span class="name">lambda</span> x . y (<span class="name">x</span> x)) (<span class="name">lambda</span> x . y (<span class="name">x</span> x))) f</span><br><span class="line">    = (<span class="name">lambda</span> x . f (<span class="name">x</span> x)) (<span class="name">lambda</span> x . f (<span class="name">x</span> x)) </span><br><span class="line">    = (<span class="name">lambda</span> x . f (<span class="name">x</span> x)) (<span class="name">lambda</span> a . f (<span class="name">a</span> a))</span><br><span class="line">    = f ((<span class="name">lambda</span> a . f (<span class="name">a</span> a)) (<span class="name">lambda</span> a . f (<span class="name">a</span> a)))</span><br><span class="line">    = f ((<span class="name">lambda</span> x . f (<span class="name">x</span> x)) (<span class="name">lambda</span> x . f (<span class="name">x</span> x)))</span><br><span class="line">    = f (<span class="name">Y</span>(<span class="name">f</span>))</span><br></pre></td></tr></table></figure>
<p>于是，<code>factorial</code>的定义就可以写成：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factorial <span class="built_in">n</span> = (Y metafact) <span class="built_in">n</span> </span><br><span class="line">            = &#123;[lambda y . (lambda <span class="built_in">t</span> . y (<span class="built_in">t</span> <span class="built_in">t</span>)) (lambda <span class="built_in">t</span> . y (<span class="built_in">t</span> <span class="built_in">t</span>))]</span><br><span class="line">               [lambda f . lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( f (Pred <span class="built_in">n</span>)))]&#125; <span class="built_in">n</span></span><br></pre></td></tr></table></figure>
<p>这下不用引用自身了。</p>
<h2 id="Y怎么来的"><a href="#Y怎么来的" class="headerlink" title="Y怎么来的"></a>Y怎么来的</h2><p>现在回到第一版的阶乘。我们虽然不能直接引用自身，但可以把它作为参数传进来，也就是说：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fact2 = lambda f. lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( f (Pred <span class="built_in">n</span>)))</span><br></pre></td></tr></table></figure>
<p>这样，在计算5的阶乘时，我们只需要计算<code>fact2(fact2, 5)</code>就可以了。定义并没有引用自身，只是在使用的时候把自己当参数传过去。是不是很简单？</p>
<p>但是，这个计算式是错误的：fact2的定义要求它接受两个参数，其中参数f是只接受一个参数的函数，于是计算式中第二个的fact2在参数数量上是无法和定义中的f匹配的。那怎么办？</p>
<p>不要紧，我们可以修改一下f的形式，让它接受两个参数。即：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fact3 = lambda f. lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( f [f, (Pred <span class="built_in">n</span>)]))</span><br></pre></td></tr></table></figure>
<p>这下计算<code>fact3(fact3, 5)</code>就不会出错了。除了这个定义有点丑……</p>
<p>如果对fact3做下化简又如何呢？首先是对拥有两个参数的f进行柯里化变换：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fact3 = lambda h . lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( h h (Pred <span class="built_in">n</span>))) </span><br><span class="line">          = lambda h . lambda <span class="built_in">n</span> . IsZero <span class="built_in">n</span> <span class="number">1</span> (Mult <span class="built_in">n</span> ( (h h) (Pred <span class="built_in">n</span>)))</span><br></pre></td></tr></table></figure>
<p>这样计算阶乘的方式也相应变成了<code>(fact3 fact3) 5</code>。接着把<code>(h h)</code>用函数<code>q</code>代替，则有</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fact3 = lambda h . lambda n . [lambda <span class="keyword">q</span> . IsZero n <span class="number">1</span> (Mult n ( <span class="string">q (Pred n)</span>))] (h h)</span><br><span class="line">          = lambda h . [lambda n . lambda <span class="keyword">q</span> . IsZero n <span class="number">1</span> (Mult n ( <span class="string">q (Pred n)</span>))] (h h)</span><br></pre></td></tr></table></figure>
<p>仔细观察中括号部分，参数h对于这部分是完全自由的，于是我们可以用另一个函数定义替换之：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> f0 = <span class="built_in">lambda</span> n . <span class="built_in">lambda</span> q . IsZero n <span class="number">1</span> (Mult n ( q (Pred n)))</span><br><span class="line"><span class="built_in">let</span> fact3 = <span class="built_in">lambda</span> h . f0 (h h)</span><br></pre></td></tr></table></figure>
<p>是不是觉得<code>f0</code>眼熟？没错，这就是<code>metafact</code>！不过我们先把<code>f0</code>放一边，看看如何使用这个定义计算n的阶乘。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">factorail n = (<span class="name">fact3</span> fact3) n </span><br><span class="line">            = (<span class="name">lambda</span> h . f0 (<span class="name">h</span> h)) (<span class="name">lambda</span> h . f0 (<span class="name">h</span> h)) n</span><br></pre></td></tr></table></figure>
<p>把上面的式子写成 <code>function_name x</code>的形式：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factorial</span> n = &#123;[<span class="built_in">lambda</span> f . (<span class="built_in">lambda</span> h . f (h h)) (<span class="built_in">lambda</span> h . f (h h))] f0&#125; n</span><br></pre></td></tr></table></figure>
<p>注意大括号中的部分，是不是更眼熟了？这就是Y的定义。真是怎么绕都扰不过去的Y啊……</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factorial <span class="built_in">n</span> = &#123;[lambda f . (lambda h . f (h h)) (lambda h . f (h h))] <span class="symbol">f0</span>&#125; <span class="built_in">n</span></span><br><span class="line">            = &#123;Y <span class="symbol">f0</span>&#125; <span class="built_in">n</span></span><br><span class="line">            = (Y metafact) <span class="built_in">n</span></span><br></pre></td></tr></table></figure>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/lambda演算/">lambda演算</a></div><div class="post-nav"><a class="pre" href="/2020/02/09/从Lambda演算到组合子演算/">【第五章】从Lambda演算到组合子演算</a><a class="next" href="/2020/02/09/Lambda演算中的布尔值和选择/">【第三章】Lambda演算中的布尔值和选择</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80ODEzMS8yNDYyOA=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://itachi321.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/函数式编程/">函数式编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全协议/">安全协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/形式化/">形式化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Haskell/" style="font-size: 15px;">Haskell</a> <a href="/tags/lambda演算/" style="font-size: 15px;">lambda演算</a> <a href="/tags/tamarin/" style="font-size: 15px;">tamarin</a> <a href="/tags/形式化/" style="font-size: 15px;">形式化</a> <a href="/tags/TLS/" style="font-size: 15px;">TLS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/终章，Lambda演算建模程序即证明！/">【第七章】终章，Lambda演算建模程序即证明！</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/Lambda演算的类型/">【第六章】Lambda演算的类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/从Lambda演算到组合子演算/">【第五章】从Lambda演算到组合子演算</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/为什么是Y？/">【第四章】为什么是Y？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/Lambda演算中的布尔值和选择/">【第三章】Lambda演算中的布尔值和选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/lambda演算中的数字/">【第二章】阿隆佐.丘奇的天才之作——lambda演算中的数字</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/lambda演算/">【第一章】我的最爱Lambda演算</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/tamarin-builtin/">tamarin Built-in message theories</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/Haskell介绍/">Haskell介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/30/TLS1-3/">TLS1.3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://csp.whu.edu.cn" title="珞珈之戍" target="_blank">珞珈之戍</a><ul></ul><a href="https://zhangtong16.github.io/" title="zhangtong16" target="_blank">zhangtong16</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Itachi's Blog.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>